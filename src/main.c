#include <stdio.h>
#include <unistd.h>
#include <getopt.h>
#include <stdlib.h>
#include <gmp.h>
#include "ex_mpn.h"
#include "dlog.h"
#include "const.h"
#include "mem.h"

const unsigned int BLOCK_BUFFER_SIZE = 1024;
int str_init_readline(char** pbuffer)
{
    char c = 's';
    int buffer_size = BLOCK_BUFFER_SIZE;
    int str_len = 0;
    (*pbuffer) = (char*) malloc_exit_when_null(buffer_size);

    ssize_t nbytes_read;
    while (c != '\0') {
        // Read character
        nbytes_read = read(STDIN_FILENO, &c, 1);
        if (!nbytes_read || c == '\n' || c == '\0')
            c = '\0';
        else if (c < '0' || c > '9')
            continue;

        // Reallocate if needed
        if (str_len == buffer_size) {
            buffer_size += BLOCK_BUFFER_SIZE;
            (*pbuffer) = (char*) realloc(*pbuffer, buffer_size);
        }

        (*pbuffer)[str_len++] = c;
    }

    return str_len;
}

unsigned int parse_arg_uint(char* arg, unsigned int default_val)
{
    long int val = default_val;
    if (arg) {
        val = strtol(arg, NULL, 10);
        if (val == 0 || val == LONG_MAX || val == LONG_MIN)
            val = default_val;
        else
            val = abs(val);
    }
    return (unsigned int) val;
}

void main(int argc, char** argv)
{
    // Get value from arguments.
    unsigned int NUM_THREADS     = DEFAULT_NUM_THREADS;
    unsigned int NUM_CACHE_ITEMS = DEFAULT_NUM_CACHE_ITEMS;
    unsigned int NUM_RAND_ITEMS  = DEFAULT_NUM_RAND_ITEMS;
    
    int opt;
    while ((opt = getopt(argc, argv, "t:c:r:h")) != -1) {
        switch (opt) {
            case 't':
                NUM_THREADS = parse_arg_uint(optarg, DEFAULT_NUM_THREADS);
                break;
            case 'c':
                NUM_CACHE_ITEMS = parse_arg_uint(optarg, DEFAULT_NUM_CACHE_ITEMS);
                break;
            case 'r':
                NUM_RAND_ITEMS = parse_arg_uint(optarg, DEFAULT_NUM_RAND_ITEMS);
                break;
            default:
                fprintf(stderr, "[usage]: %s [-t num_threads=4] [-c num_cache_items=4] [-r nrandpoints=20]\n", argv[0]);
                exit(-1);
        }
    }

    // Parse curve values from stdin.
    char* p_str;        // field
    char* G_str;        // g
    char* kG_str;       // g^k mod p
    char* n_str;        // order of multiplicative group generated by g.

    str_init_readline(&p_str);
    str_init_readline(&G_str);
    str_init_readline(&kG_str);
    str_init_readline(&n_str);

    // str -> mpz_t
    mpz_t p;
    mpz_init_set_str(p, p_str, 10);
    mpz_t G;
    mpz_init_set_str(G, G_str, 10);
    mpz_t kG;
    mpz_init_set_str(kG, kG_str, 10);
    mpz_t n;
    mpz_init_set_str(n, n_str, 10);

    // dlog() start.
    mpz_t k;
    mpz_init(k);
    if (dlog(p, k, G, kG, n, NUM_THREADS, NUM_CACHE_ITEMS, NUM_RAND_ITEMS) == DLOG_SUCCESS) {
        mpz_out_str(stdout, 10, k);
        printf("\n");
    }
    else {
        printf("None\n");
    }

    // cleanup.
    mpz_clear(k);
    mpz_clear(n);
    mpz_clear(kG);
    mpz_clear(G);
    mpz_clear(p);

    free(p_str);
    free(G_str);
    free(kG_str);
    free(n_str);
}